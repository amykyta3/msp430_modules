<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A Library of MSP430 C Code: Cooperative Threads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Library of MSP430 C Code
   </div>
   <div id="projectbrief">Collection of peripheral drivers, component drivers, utilities, and other commonly used embedded code.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Cooperative Threads</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cooperative Processor Threads.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cooperative Processor Threads. </p>
<dl class="section author"><dt>Author</dt><dd>Alex Mykyta</dd></dl>
<p>Provides a lightweight method of implementing cooperative threads for the MSP430. Alternate thread contexts operate in separate stack space that can be dynamically allocated in the heap or from within the base thread's stack.</p>
<dl class="section warning"><dt>Warning</dt><dd>No measures are taken to prevent stack overflows! Be sure to allocate enough stack space for the alternate thread. Make sure to account for any interrupt service routines that may trigger from within it.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Add support for TI compiler. cothread_setjmp is currently only designed for msp430-elf's ABI</dd></dl>
<p><b>Example</b> <br />
In this simple example, two different threads control two separate LED outputs. When executed, the LED on P2.1 blinks three times, stops, then the LED on P2.2 blinks twice. This sequence repeats forever.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;msp430.h&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cothread_8h.html">cothread.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">stack_t my_alt_stack[64];</div><div class="line"></div><div class="line">cothread_t home_thread; <span class="comment">// Home thread object</span></div><div class="line">cothread_t my_alt_thread;    <span class="comment">// Alternate thread object</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> alt_thread_func(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">// Stop watchdog timer</span></div><div class="line">    </div><div class="line">    <span class="comment">// Lets say that P2.1 and P2.2 are LEDs</span></div><div class="line">    P2DIR |= BIT1 | BIT2;</div><div class="line">    P2OUT &amp;= ~(BIT1 | BIT2);</div><div class="line">    </div><div class="line">    <span class="comment">// Initialize cothreads and populate the home thread object</span></div><div class="line">    <a class="code" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga652cb65909b73735cd5363af50364335">cothread_init</a>(&amp;home_thread);</div><div class="line">    </div><div class="line">    <span class="comment">// Setup the my_alt_thread object and create the new thread context</span></div><div class="line">    my_alt_thread.alt_stack = my_alt_stack; <span class="comment">// it will use my_alt_stack for its stack storage</span></div><div class="line">    my_alt_thread.alt_stack_size = <span class="keyword">sizeof</span>(my_alt_stack); <span class="comment">// I hope its big enough!</span></div><div class="line">    my_alt_thread.co_exit = &amp;home_thread; <span class="comment">// If the thread exits, it will return to the home_thread</span></div><div class="line">    <a class="code" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#gaa438309a3f8d5e15e511a4fb22364b35">cothread_create</a>(&amp;my_alt_thread,alt_thread_func);</div><div class="line">    </div><div class="line">    <span class="keywordflow">while</span>(1){</div><div class="line">        P2OUT |= BIT1; <span class="comment">// P2.1 ON</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        P2OUT &amp;= ~BIT1; <span class="comment">// P2.1 OFF</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        P2OUT |= BIT1; <span class="comment">// P2.1 ON</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        P2OUT &amp;= ~BIT1; <span class="comment">// P2.1 OFF</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        </div><div class="line">        <a class="code" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78">cothread_switch</a>(&amp;my_alt_thread);</div><div class="line">    }</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span>(0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> alt_thread_func(<span class="keywordtype">void</span>){</div><div class="line">    <span class="keywordflow">while</span>(1){</div><div class="line">        P2OUT |= BIT2; <span class="comment">// P2.2 ON</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        P2OUT &amp;= ~BIT2; <span class="comment">// P2.2 OFF</span></div><div class="line">        __delay_cycles(250000);</div><div class="line">        </div><div class="line">        <a class="code" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78">cothread_switch</a>(&amp;home_thread);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span>(0);</div><div class="line">}</div></div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__state__t.html">m_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcothread.html">cothread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga89d1de81efb5b232fcd19f11ca648d42"><td class="memItemLeft" align="right" valign="top"><a id="ga89d1de81efb5b232fcd19f11ca648d42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LFSR_INIT</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:ga89d1de81efb5b232fcd19f11ca648d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9c24972f0467f94904a953cf13de83be"><td class="memItemLeft" align="right" valign="top">typedef uintptr_t stack_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga9c24972f0467f94904a953cf13de83be">__attribute__</a>((aligned(__BIGGEST_ALIGNMENT__)))</td></tr>
<tr class="separator:ga9c24972f0467f94904a953cf13de83be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga652cb65909b73735cd5363af50364335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga652cb65909b73735cd5363af50364335">cothread_init</a> (cothread_t *home_thread)</td></tr>
<tr class="memdesc:ga652cb65909b73735cd5363af50364335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the home thread object.  <a href="#ga652cb65909b73735cd5363af50364335">More...</a><br /></td></tr>
<tr class="separator:ga652cb65909b73735cd5363af50364335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa438309a3f8d5e15e511a4fb22364b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#gaa438309a3f8d5e15e511a4fb22364b35">cothread_create</a> (cothread_t *thread, int(*func)(void))</td></tr>
<tr class="memdesc:gaa438309a3f8d5e15e511a4fb22364b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new cooperative thread.  <a href="#gaa438309a3f8d5e15e511a4fb22364b35">More...</a><br /></td></tr>
<tr class="separator:gaa438309a3f8d5e15e511a4fb22364b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11774608c9fc82e64e70f47e8e8b5b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78">cothread_switch</a> (cothread_t *dest_thread)</td></tr>
<tr class="memdesc:ga11774608c9fc82e64e70f47e8e8b5b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to a different context.  <a href="#ga11774608c9fc82e64e70f47e8e8b5b78">More...</a><br /></td></tr>
<tr class="separator:ga11774608c9fc82e64e70f47e8e8b5b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053be08e9068db02e4711f924ed598e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga2053be08e9068db02e4711f924ed598e">cothread_exit</a> (int retval)</td></tr>
<tr class="memdesc:ga2053be08e9068db02e4711f924ed598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the current thread.  <a href="#ga2053be08e9068db02e4711f924ed598e">More...</a><br /></td></tr>
<tr class="separator:ga2053be08e9068db02e4711f924ed598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad882c136b9ccb05db7fd929ccc5602d0"><td class="memItemLeft" align="right" valign="top"><a id="gad882c136b9ccb05db7fd929ccc5602d0"></a>
struct <a class="el" href="structcothread.html">cothread</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((aligned(__BIGGEST_ALIGNMENT__)))</td></tr>
<tr class="separator:gad882c136b9ccb05db7fd929ccc5602d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:cothread_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cothread_8c.html">cothread.c</a></td></tr>
<tr class="memdesc:cothread_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html">Cooperative Threads</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cothread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cothread_8h.html">cothread.h</a></td></tr>
<tr class="memdesc:cothread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include file for <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html">Cooperative Threads</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stack Monitor Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp45047f1c761e73b67fbb0765b1b7980b"></a>These functions allow the developer to determine how much space remains in a thread's alternate stack. The <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga983f0a5993d182668f5d3dd77764d6b5" title="Fill the space allocated for an alternate stack with a pseudorandom sequence. ">stackmon_init()</a> function fills the stack with a pseudorandom number sequence. As the stack is used, these values are overwritten. The <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga556e29fbda7f780fa5cca5822f8210f4" title="Determine how much of the stack was untouched by program execution. ">stackmon_get_unused()</a> function determines how many bytes of the pseudorandom sequence remain. </p>
</td></tr>
<tr class="memitem:ga983f0a5993d182668f5d3dd77764d6b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga983f0a5993d182668f5d3dd77764d6b5">stackmon_init</a> (stack_t *stack, size_t stack_size)</td></tr>
<tr class="memdesc:ga983f0a5993d182668f5d3dd77764d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the space allocated for an alternate stack with a pseudorandom sequence.  <a href="#ga983f0a5993d182668f5d3dd77764d6b5">More...</a><br /></td></tr>
<tr class="separator:ga983f0a5993d182668f5d3dd77764d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556e29fbda7f780fa5cca5822f8210f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga556e29fbda7f780fa5cca5822f8210f4">stackmon_get_unused</a> (stack_t *stack)</td></tr>
<tr class="memdesc:ga556e29fbda7f780fa5cca5822f8210f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how much of the stack was untouched by program execution.  <a href="#ga556e29fbda7f780fa5cca5822f8210f4">More...</a><br /></td></tr>
<tr class="separator:ga556e29fbda7f780fa5cca5822f8210f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9c24972f0467f94904a953cf13de83be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c24972f0467f94904a953cf13de83be">&#9670;&nbsp;</a></span>__attribute__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__inline__ __attribute__</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>MSPGCC compiles this with a bunch of actual shifts. Rewrite as an asm macro </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa438309a3f8d5e15e511a4fb22364b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa438309a3f8d5e15e511a4fb22364b35">&#9670;&nbsp;</a></span>cothread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cothread_create </td>
          <td>(</td>
          <td class="paramtype">cothread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new cooperative thread. </p>
<p>Before the call to this function, the <code>co_exit</code>, <code>alt_stack</code>, and <code>alt_stack_size</code> elements of the <code>thread</code> structure must be initialized. The <code>alt_stack</code> and <code>alt_stack_size</code> elements describe the stack which is used for this thread. No two threads which are used at the same time should use the same memory region for a stack.</p>
<p>The <code>co_exit</code> element of the object pointed to by <code>thread</code> must be set to the thread to be switched to when the function func returns or when the thread exits using <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga2053be08e9068db02e4711f924ed598e" title="Terminates the current thread. ">cothread_exit()</a></p>
<dl class="section note"><dt>Note</dt><dd>When the entry function <code>func</code> launches, global interrupts are disabled regardless of the parent thread's state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to a user context </td></tr>
    <tr><td class="paramname">func</td><td>Entry function for the new thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2053be08e9068db02e4711f924ed598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053be08e9068db02e4711f924ed598e">&#9670;&nbsp;</a></span>cothread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cothread_exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>retval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>This value becomes the return value of the <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78" title="Switch to a different context. ">cothread_switch()</a> function in the other thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga652cb65909b73735cd5363af50364335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652cb65909b73735cd5363af50364335">&#9670;&nbsp;</a></span>cothread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cothread_init </td>
          <td>(</td>
          <td class="paramtype">cothread_t *&#160;</td>
          <td class="paramname"><em>home_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the home thread object. </p>
<p>This function should be called prior to using any other cothread routines </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">home_thread</td><td>pointer to an uninitialized cothread_t object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11774608c9fc82e64e70f47e8e8b5b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11774608c9fc82e64e70f47e8e8b5b78">&#9670;&nbsp;</a></span>cothread_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cothread_switch </td>
          <td>(</td>
          <td class="paramtype">cothread_t *&#160;</td>
          <td class="paramname"><em>dest_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to a different context. </p>
<p>Upon calling <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78" title="Switch to a different context. ">cothread_switch()</a>, the state of the current thread is saved and the thread pointed to by <code>dest_thread</code> is loaded. The current thread resumes after the function call once it has been switched back to.</p>
<p>If <code>dest_thread</code> has been previously terminated, execution will continue in the current thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_thread</td><td>Pointer to the destination thread to switch to </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If the previous thread switched here normally using a call to <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#ga11774608c9fc82e64e70f47e8e8b5b78" title="Switch to a different context. ">cothread_switch()</a> </td></tr>
    <tr><td class="paramname">-1</td><td>If it was not possible to switch to <code>dest_thread</code> </td></tr>
    <tr><td class="paramname">other</td><td>Returns the exit value that the thread terminated with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga556e29fbda7f780fa5cca5822f8210f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556e29fbda7f780fa5cca5822f8210f4">&#9670;&nbsp;</a></span>stackmon_get_unused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stackmon_get_unused </td>
          <td>(</td>
          <td class="paramtype">stack_t *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how much of the stack was untouched by program execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Pointer to the allocated stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes remaining in the stack. </dd></dl>

</div>
</div>
<a id="ga983f0a5993d182668f5d3dd77764d6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga983f0a5993d182668f5d3dd77764d6b5">&#9670;&nbsp;</a></span>stackmon_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stackmon_init </td>
          <td>(</td>
          <td class="paramtype">stack_t *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the space allocated for an alternate stack with a pseudorandom sequence. </p>
<dl class="section note"><dt>Note</dt><dd>This must be done <em>prior</em> to calling <a class="el" href="group___m_o_d___c_o_t_h_r_e_a_d_s.html#gaa438309a3f8d5e15e511a4fb22364b35" title="Initializes a new cooperative thread. ">cothread_create()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Pointer to the allocated stack </td></tr>
    <tr><td class="paramname">stack_size</td><td>The size of the stack in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 12 2018 21:23:53 for A Library of MSP430 C Code by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
